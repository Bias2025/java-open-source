You are building a financial services frontend that must handle sensitive financial data, 
regulatory compliance, and real-time market information. Your expertise spans:
- 20+ years building trading platforms and banking applications
- Deep knowledge of financial regulations (SOX, GDPR, PCI-DSS, MiFID II)
- Experience with high-frequency data updates and real-time calculations

FINANCIAL_CONTEXT:
Application Name: Enterprise Financial Dashboard
Business Domain: Investment Banking / Wealth Management
User Base: 10,000+ financial advisors and traders
Primary Purpose: Portfolio management, trading, risk analysis, compliance reporting
Backend: Spring Boot REST API with PostgreSQL (financial data warehouse)
Design System: LegoUX Component Library (enterprise edition)
Regulatory Requirements: SOX compliance, GDPR, PCI-DSS Level 1
Data Sensitivity: Handling PII, financial transactions, market data
FUNCTIONAL_REQUIREMENTS:
1. Core Financial Workflows:
   - Portfolio Management: View/edit client portfolios, rebalancing, performance tracking
   - Trading Execution: Order entry, market/limit orders, order book management
   - Risk Analysis: VaR calculations, exposure monitoring, stress testing
   - Compliance Reporting: Regulatory reports, audit trails, transaction monitoring
   - Client Management: KYC/AML workflows, client onboarding, document management

2. Financial Data Entities:
   Entity: Portfolio
   - Fields: portfolioId, clientId, totalValue, currency, holdings[], performance
   - Operations: create, read, update, rebalance, analyze, report
   
   Entity: Transaction
   - Fields: transactionId, type, amount, currency, timestamp, status, fees
   - Operations: create, read, approve, reject, settle, reconcile
   
   Entity: MarketData
   - Fields: symbol, price, bid, ask, volume, timestamp, exchange
   - Operations: subscribe, unsubscribe, historical, real-time
   
   Entity: ComplianceReport
   - Fields: reportId, type, period, status, violations[], approvals[]
   - Operations: generate, review, approve, submit, archive

3. Financial User Roles:
   - Trader: Execute trades, view market data, manage orders
   - Portfolio Manager: Manage client portfolios, risk analysis, reporting
   - Compliance Officer: Review transactions, generate reports, audit
   - Client Advisor: View client data, portfolio performance, recommendations
   - Administrator: User management, system configuration, audit logs

NON_FUNCTIONAL_REQUIREMENTS:
- Performance: Sub-100ms response for market data, real-time updates via WebSocket
- Availability: 99.99% uptime (52 minutes downtime/year max)
- Data Accuracy: 6 decimal precision for financial calculations
- Audit: Complete audit trail for all financial operations
- Security: End-to-end encryption, MFA, session management
FINANCIAL_FRONTEND_ARCHITECTURE:
Pattern: Micro-Frontend Architecture with Domain Isolation
Structure:
├── src/
│   ├── app/
│   │   ├── core/
│   │   │   ├── auth/          # OAuth2, MFA, session management
│   │   │   ├── audit/         # Audit logging service
│   │   │   ├── compliance/    # Compliance checking utilities
│   │   │   └── market-data/   # Real-time market data service
│   │   ├── domains/
│   │   │   ├── trading/       # Trading module
│   │   │   ├── portfolio/     # Portfolio management
│   │   │   ├── risk/          # Risk analysis
│   │   │   ├── compliance/    # Compliance reporting
│   │   │   └── client/        # Client management
│   │   ├── shared/
│   │   │   ├── financial-components/  # Reusable financial UI
│   │   │   ├── calculators/          # Financial calculations
│   │   │   └── formatters/           # Currency, number formatting
│   │   └── models/
│   │       ├── financial/     # Financial DTOs
│   │       └── regulatory/    # Compliance models

REAL_TIME_INTEGRATION:
- WebSocket connection for market data
- Server-Sent Events for portfolio updates
- Polling fallback for restricted environments
FINANCIAL_COMPONENT_GENERATION:

1. TRADING INTERFACE:
@Component({
  selector: 'app-trading-desk',
  template: `
    <lego-card class="trading-panel">
      <lego-card-header>
        <h2>Order Entry</h2>
        <lego-badge [color]="marketStatus">{{marketStatusText}}</lego-badge>
      </lego-card-header>
      <lego-card-content>
        <form [formGroup]="orderForm" (ngSubmit)="submitOrder()">
          <lego-form-field>
            <lego-label>Symbol</lego-label>
            <input legoInput 
                   formControlName="symbol" 
                   [legoAutocomplete]="symbolSearch"
                   aria-label="Trading symbol">
            <lego-error *ngIf="orderForm.get('symbol')?.hasError('invalid')">
              Invalid symbol
            </lego-error>
          </lego-form-field>
          
          <lego-form-field>
            <lego-label>Order Type</lego-label>
            <lego-select formControlName="orderType">
              <lego-option value="MARKET">Market</lego-option>
              <lego-option value="LIMIT">Limit</lego-option>
              <lego-option value="STOP">Stop</lego-option>
            </lego-select>
          </lego-form-field>
          
          <lego-form-field>
            <lego-label>Quantity</lego-label>
            <input legoInput 
                   type="number" 
                   formControlName="quantity"
                   [min]="1"
                   aria-label="Order quantity">
          </lego-form-field>
          
          <lego-button type="submit" 
                       [disabled]="!orderForm.valid || submitting"
                       color="primary">
            <lego-icon name="send"></lego-icon>
            Submit Order
          </lego-button>
        </form>
      </lego-card-content>
    </lego-card>
  `,
  changeDetection: ChangeDetectionStrategy.OnPush
})
export class TradingDeskComponent implements OnInit {
  // Implementation with real-time validation
  // Compliance checks before submission
  // Audit trail generation
}

2. PORTFOLIO DASHBOARD:
@Component({
  selector: 'app-portfolio-dashboard',
  template: `
    <lego-grid>
      <lego-grid-row>
        <lego-grid-col [span]="8">
          <lego-card>
            <lego-card-header>
              <h2>Portfolio Performance</h2>
              <lego-date-range-picker 
                [(ngModel)]="dateRange"
                (change)="updatePerformance()">
              </lego-date-range-picker>
            </lego-card-header>
            <lego-card-content>
              <lego-chart type="line" 
                          [data]="performanceData"
                          [options]="chartOptions">
              </lego-chart>
            </lego-card-content>
          </lego-card>
        </lego-grid-col>
        
        <lego-grid-col [span]="4">
          <lego-card>
            <lego-card-header>Risk Metrics</lego-card-header>
            <lego-card-content>
              <lego-stat-group>
                <lego-stat label="VaR (95%)" 
                           [value]="riskMetrics.var95"
                           format="currency">
                </lego-stat>
                <lego-stat label="Sharpe Ratio" 
                           [value]="riskMetrics.sharpe"
                           format="number:1.2">
                </lego-stat>
                <lego-stat label="Beta" 
                           [value]="riskMetrics.beta"
                           format="number:1.3">
                </lego-stat>
              </lego-stat-group>
            </lego-card-content>
          </lego-card>
        </lego-grid-col>
      </lego-grid-row>
    </lego-grid>
  `
})
export class PortfolioDashboardComponent {
  // Real-time portfolio updates
  // Risk calculations
  // Performance attribution
}

3. MARKET DATA GRID:
@Component({
  selector: 'app-market-data-grid',
  template: `
    <lego-data-table [dataSource]="marketDataSource"
                     [columns]="columns"
                     [sortable]="true"
                     [filterable]="true"
                     [virtualScroll]="true"
                     class="financial-grid">
      <ng-container *legoColumnDef="'symbol'">
        <lego-header-cell *legoHeaderCellDef>Symbol</lego-header-cell>
        <lego-cell *legoCellDef="let row">
          <lego-link [routerLink]="['/security', row.symbol]">
            {{row.symbol}}
          </lego-link>
        </lego-cell>
      </ng-container>
      
      <ng-container *legoColumnDef="'price'">
        <lego-header-cell *legoHeaderCellDef>Price</lego-header-cell>
        <lego-cell *legoCellDef="let row" class="numeric">
          <span [class.positive]="row.change > 0"
                [class.negative]="row.change < 0">
            {{row.price | currency:row.currency:'symbol':'1.2-4'}}
          </span>
        </lego-cell>
      </ng-container>
      
      <ng-container *legoColumnDef="'change'">
        <lego-header-cell *legoHeaderCellDef>Change</lego-header-cell>
        <lego-cell *legoCellDef="let row" class="numeric">
          <lego-trend-indicator [value]="row.change"
                                [format]="'percent'">
          </lego-trend-indicator>
        </lego-cell>
      </ng-container>
    </lego-data-table>
  `
})
export class MarketDataGridComponent implements OnInit, OnDestroy {
  private marketDataSubscription: Subscription;
  
  ngOnInit() {
    // WebSocket connection for real-time updates
    this.marketDataSubscription = this.marketDataService
      .connectRealTime()
      .subscribe(update => this.updateGrid(update));
  }
}
SPRING_BOOT_FINANCIAL_API_INTEGRATION:

1. TYPE-SAFE API CLIENT:
@Injectable({ providedIn: 'root' })
export class TradingApiService {
  constructor(
    private http: HttpClient,
    private audit: AuditService
  ) {}
  
  submitOrder(order: OrderRequest): Observable<OrderResponse> {
    // Audit trail
    this.audit.log('ORDER_SUBMISSION', order);
    
    return this.http.post<OrderResponse>('/api/v1/trading/orders', order)
      .pipe(
        retry({ count: 3, delay: 1000 }),
        catchError(this.handleFinancialError),
        tap(response => this.audit.log('ORDER_RESPONSE', response))
      );
  }
  
  private handleFinancialError(error: HttpErrorResponse): Observable<never> {
    if (error.status === 402) {
      throw new InsufficientFundsError(error.error);
    }
    if (error.status === 409) {
      throw new ComplianceViolationError(error.error);
    }
    throw new TradingError(error.message);
  }
}

2. REAL-TIME MARKET DATA SERVICE:
@Injectable({ providedIn: 'root' })
export class MarketDataService {
  private ws: WebSocket;
  private reconnectAttempts = 0;
  
  connectRealTime(): Observable<MarketUpdate> {
    return new Observable(observer => {
      this.ws = new WebSocket('wss://api.example.com/market-data');
      
      this.ws.onmessage = (event) => {
        const update = this.parseMarketUpdate(event.data);
        observer.next(update);
      };
      
      this.ws.onerror = () => {
        this.reconnect();
      };
      
      return () => this.ws.close();
    }).pipe(
      share(),
      retryWhen(errors => errors.pipe(
        delay(Math.min(1000 * Math.pow(2, this.reconnectAttempts++), 30000))
      ))
    );
  }
}

3. COMPLIANCE CHECKING:
@Injectable({ providedIn: 'root' })
export class ComplianceService {
  async checkTradeCompliance(trade: TradeRequest): Promise<ComplianceResult> {
    const checks = await Promise.all([
      this.checkRegulatoryLimits(trade),
      this.checkClientRestrictions(trade),
      this.checkMarketRules(trade),
      this.checkInternalPolicies(trade)
    ]);
    
    return {
      approved: checks.every(c => c.passed),
      violations: checks.filter(c => !c.passed).map(c => c.violation),
      warnings: checks.filter(c => c.warning).map(c => c.warning)
    };
  }
}
FINANCIAL_TESTING_SUITE:

1. CALCULATION ACCURACY TESTS:
describe('FinancialCalculatorService', () => {
  it('should calculate portfolio returns with 6 decimal precision', () => {
    const portfolio = portfolioFactory({
      holdings: [
        { symbol: 'AAPL', quantity: 100, purchasePrice: 150.00 },
        { symbol: 'GOOGL', quantity: 50, purchasePrice: 2800.00 }
      ]
    });
    
    const returns = calculator.calculateReturns(portfolio, currentPrices);
    expect(returns.absolute).toBeCloseTo(12500.123456, 6);
    expect(returns.percentage).toBeCloseTo(0.089285, 6);
  });
  
  it('should handle currency conversion accurately', () => {
    const amount = 1000000.00;
    const rate = 1.18523; // EUR/USD
    const converted = calculator.convert(amount, 'EUR', 'USD');
    expect(converted).toBe(1185230.00); // Exactly 2 decimal places
  });
});

2. COMPLIANCE VALIDATION TESTS:
describe('ComplianceService', () => {
  it('should reject trades exceeding position limits', async () => {
    const trade = tradeFactory({
      symbol: 'AAPL',
      quantity: 1000000,
      clientId: 'CLIENT001'
    });
    
    const result = await compliance.checkTradeCompliance(trade);
    expect(result.approved).toBe(false);
    expect(result.violations).toContain('POSITION_LIMIT_EXCEEDED');
  });
});

3. REAL-TIME DATA TESTS:
describe('MarketDataService', () => {
  it('should handle WebSocket reconnection', fakeAsync(() => {
    const mockWs = new MockWebSocket();
    service.connectRealTime().subscribe();
    
    mockWs.triggerError();
    tick(1000); // First reconnect after 1s
    expect(mockWs.connectAttempts).toBe(2);
    
    mockWs.triggerError();
    tick(2000); // Second reconnect after 2s (exponential backoff)
    expect(mockWs.connectAttempts).toBe(3);
  }));
});
FINANCIAL_SECURITY_IMPLEMENTATION:

1. AUTHENTICATION:
- Multi-factor authentication (MFA) required
- Session timeout after 15 minutes of inactivity
- Device fingerprinting for fraud detection
- IP whitelisting for sensitive operations

2. DATA PROTECTION:
- End-to-end encryption for all financial data
- PCI-DSS compliant credit card handling
- GDPR-compliant PII management
- Data masking in non-production environments

3. AUDIT TRAIL:
@Injectable()
export class AuditService {
  logFinancialOperation(operation: FinancialOperation): void {
    const auditEntry: AuditLog = {
      timestamp: new Date().toISOString(),
      userId: this.auth.currentUser.id,
      operation: operation.type,
      details: this.sanitizeForAudit(operation.data),
      ipAddress: this.getClientIP(),
      sessionId: this.session.id,
      checksum: this.calculateChecksum(operation)
    };
    
    this.http.post('/api/audit', auditEntry).subscribe();
  }
}
