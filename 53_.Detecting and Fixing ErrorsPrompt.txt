# CRAFT-ENHANCED JAVA CODE ANALYSIS & REMEDIATION PROMPT
# Generated by Development Collective

## C - CONTEXT (Environmental Understanding)
CONTEXT:
  analysis_scope: "Production-Grade Java/Spring Boot Code Review"
  target_environment: 
    - Java_version: "17+ LTS"
    - Spring_Boot: "3.x preferred, 2.x compatible"
    - deployment: "Cloud-native/Kubernetes-ready"
  team_expertise: "Mixed (Junior to Senior developers)"
  compliance_requirements:
    - OWASP_Top_10: "mandatory"
    - GDPR: "if applicable"
    - PCI_DSS: "if payment processing"
  performance_targets:
    - response_time: "< 100ms P99"
    - throughput: "10K+ RPS capable"
    - memory_footprint: "optimized for containerization"

## R - REQUIREMENTS (Explicit Specifications)
REQUIREMENTS:
  functional_analysis:
    - Detect and fix ALL critical bugs
    - Ensure code compiles without warnings
    - Maintain backward compatibility
    - Preserve business logic integrity
  
  non_functional_analysis:
    performance:
      - Identify O(nÂ²) or worse algorithms
      - Detect N+1 query problems
      - Find unnecessary object creation
      - Locate blocking I/O in async contexts
    
    security:
      - SQL injection vulnerabilities
      - XSS attack vectors
      - Insecure deserialization
      - Hardcoded credentials
      - Weak cryptography
    
    reliability:
      - Resource leak detection
      - Proper exception handling
      - Transaction boundary issues
      - Race conditions
      - Deadlock potential

## A - ARCHITECTURE (Design Analysis)
ARCHITECTURE:
  code_patterns_to_verify:
    - SOLID principles adherence
    - DRY (Don't Repeat Yourself)
    - Clean Architecture boundaries
    - Dependency injection proper usage
    - Interface segregation
  
  spring_patterns:
    - Proper @Transactional usage
    - Correct bean scoping
    - Circular dependency detection
    - Profile-based configuration
    - Proper async/reactive usage

## F - FRAMEWORK (Technical Implementation)
FRAMEWORK:
  analysis_tools:
    - Static analysis: "SonarQube rules"
    - Security: "OWASP dependency check"
    - Performance: "JProfiler patterns"
    - Memory: "Eclipse MAT patterns"
  
  fix_strategies:
    - Use Optional<T> for nullable returns
    - Try-with-resources for AutoCloseable
    - CompletableFuture for async operations
    - @Validated for input validation
    - Circuit breakers for external calls

## T - TESTING (Verification Strategy)
TESTING:
  coverage_requirements:
    - Unit tests: ">= 90%"
    - Integration tests: "critical paths"
    - Mutation testing: ">= 75%"
  
  test_patterns:
    - Mockito for dependencies
    - TestContainers for databases
    - WireMock for external APIs
    - ArchUnit for architecture rules

---

## ANALYSIS EXECUTION INSTRUCTIONS:

### Phase 1: CRITICAL BUG DETECTION
Scan for and fix in priority order:
1. **Null Pointer Exceptions**
   - Missing null checks
   - Uninitialized fields
   - Optional misuse
   - Collection access without isEmpty()

2. **Resource Leaks**
   - Unclosed streams/readers/writers
   - Database connections not released
   - Thread pool executors not shutdown
   - Memory-mapped files not unmapped

3. **Thread Safety Issues**
   - Shared mutable state without synchronization
   - Race conditions in singleton initialization
   - Improper use of volatile
   - Deadlock scenarios

4. **Memory Leaks**
   - Static collections growing unbounded
   - Listeners not removed
   - ThreadLocal not cleared
   - Circular references preventing GC

### Phase 2: SECURITY VULNERABILITY SCAN
Identify and remediate:
- SQL/NoSQL injection points
- Path traversal vulnerabilities
- XXE (XML External Entity) attacks
- Insecure random number generation
- Sensitive data in logs

### Phase 3: PERFORMANCE OPTIMIZATION
Detect and optimize:
- Database query inefficiencies (N+1, missing indexes)
- Unnecessary object creation in loops
- String concatenation in loops (use StringBuilder)
- Inefficient collection usage
- Blocking calls in reactive streams

### Phase 4: CODE QUALITY ENHANCEMENT
Apply:
- SOLID principles
- Design patterns where appropriate
- Spring Boot best practices
- Proper logging (SLF4J with parameters)
- Comprehensive error handling

## OUTPUT FORMAT:

```java
// ============================================
// SPRING-FORGE Code Analysis Report
// CRAFT Methodology Applied
// Analysis Date: ${TIMESTAMP}
// Severity Levels: CRITICAL | HIGH | MEDIUM | LOW
// ============================================

// ISSUE #1: [CRITICAL] Null Pointer Exception Risk
// Location: Line ${LINE_NUMBER}
// Original Code:
${PROBLEMATIC_CODE}

// Root Cause:
// ${EXPLANATION}

// Fixed Code:
${CORRECTED_CODE}

// Prevention Strategy:
// ${BEST_PRACTICE_RECOMMENDATION}

// Test Case to Verify Fix:
@Test
void shouldHandleNullScenario() {
    ${TEST_CODE}
}

// Performance Impact: ${IMPACT_ASSESSMENT}
// Security Impact: ${SECURITY_ASSESSMENT}

// [Continue for each issue found...]

// ============================================
// SUMMARY METRICS:
// - Critical Issues Fixed: ${COUNT}
// - High Priority Issues: ${COUNT}
// - Medium Priority Issues: ${COUNT}
// - Low Priority Issues: ${COUNT}
// - Estimated Performance Improvement: ${PERCENTAGE}%
// - Security Score Improvement: ${SCORE}/100
// - Code Coverage Increase: ${PERCENTAGE}%
// ============================================

// RECOMMENDED NEXT STEPS:
// 1. ${ACTION_ITEM_1}
// 2. ${ACTION_ITEM_2}
// 3. ${ACTION_ITEM_3}
